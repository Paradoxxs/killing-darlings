# Copy of Malware analysis

#### Unpacking .Net application

Unpacking .net application can be a little different then other samples. use [dnspy](https://github.com/dnSpy/dnSpy) instead to open the sample as it works better with .net applications.\
One way to look for new modules. Another is looking for assembly or module loading.\
You can identify this by using the _export project/find_ option.\
The tools below will try and automate the process for you.

[de4dot](https://github.com/de4dot/de4dot) [MegaDumper](https://github.com/CodeCracker-Tools/MegaDumper)

### Ghost writing

Ghost Writing is a way of Obfuscating the binary / assembly code in such a way that the signature no longer exists due to malware code obfuscation and no functionality of the malware is lost . The Idea here is to add random Assembly instructions to the disassembly of the executable and maintaining the functionality of the malware at the sametime. This is also called ghostwriting for antivirus An common way to do this is using Metasploit msfvenom to output the malware in raw binary. use ruby libery metasm (gem install metasm) to convert the binary to assembly code. edit the assembly to scramble the signature (common way is before zero out an register using _xor_, add some random code to the pointer ) convert the assembly code to executable and you have a scrambled malware.

## API Hooking

Malware can inject code into other processes by writing into target processes memory space.\
This enabled the malware to spy on the victim activities.\
It also enable the malware to infect processes from alerting the malware by cloaking the rootkit.\
To identify this functionality using code level involves examining the sample API calls.

What should the rootkit write into the beginning of the targeted function? One option is to insert a JMP instruction that specifies the relative address of the malicious code that the hooked function will execute. The hex value of this instruction begins with 0xE9. Sometimes the rootkit uses a sneakier approach to perform a jump: It might insert the PUSH instruction (0x68) followed by the RET instruction (0xC3). Push places the address of the jump's destination to the stack. RET is typically used to return from a function, but it accomplishes this by popping an address from the top of the stack and jumping there. As a result, PUSH followed by RET can be used as a jump.

Assuming that a function was successfully hooked. When the infected process attempts to invoke it, the patched function will execute rootkit code. That code will typically want to invoke the original version of the function; otherwise, it might crash and behave unexpected.\
What the rootkit can do is backing up the overwritten function, it can execute the original function using the backup instructions.\
It can there after jump into the hooked function just past the hook portion and continue executing the remainder of the function. The effort of executing the original bytes and then jumping into the function to execute the rest of its code is called a trampoline.

Malware often uses the API call _ReadProcessMemory_ to read the targeted function's contents, and using _VirtualProtect_ If necessary, to set permissions of memory where the targeted function resides to writeable. _WriteProcessMemory_ to overwrite the start of the targeted function with jump into the rootkit.\
There are multiple method of achieving this a common method is to insert a _JMP_ to a relative address. Another is to implement a jump using _PUSH_ to push the destination address to the stack followed by _RET_ to pop the address and jump there.\
When examining malicious code, look for the combination of calls to _ReadProcessMemory_ near calls to _WriteProcessMemory_ to spot potential API hooking instructions.

Important Windows API

* ReadProcessMemory
* VirtualProtect
* WriteProcessMemory



The processes of injecting code into another processes. The victim process does not know it there have been injected code because it will run in it own thread, if you took a memory image of the system it would be very easy to find (You can use the findmal volatility plugin to locate the malware).

Because the api techniques is very platform depended I have split it up.

Windows code injection

### Unpacking

Most malware comes packed one way or the other, where the true software get unpacked during runtime, making static analysis harder.

```
VirtucalAlloc(Ex)
VirtualProtect(Ex)
WriteProcessMemory
CreateProcessInternalW
NtResumeThread
```

Determine whether the specimen is packed by using Detect It Easy, Exeinfo PE, Bytehist, peframe, etc.

To try unpacking the specimen quickly, infect the lab system and dump from memory using Scylla.

For more precision, find the Original Entry Point (OEP) in a debugger and dump with OllyDumpEx.

To find the OEP, anticipate the condition close to the end of the unpacker and set the breakpoint.

Try setting a memory breakpoint on the stack in the unpackerâ€™s beginning to catch it during cleanup.

To get closer to the OEP, set breakpoints on APIs such as LoadLibrary, VirtualAlloc, etc.

To intercept process injection set breakpoints on VirtualAllocEx, WriteProcessMemory, etc.

If cannot dump cleanly, examine the packed specimen via dynamic code analysis while it runs.

Rebuild imports and other aspects of the dumped file using Scylla, import fixer, UIF, pe\_unmapper



#### Decoding of encrypted data

You can decode data in a debugger by setting a breakpoint after the decoding function and examining results. On Windows, you can identify for decryption function by API to _CryptDecrypt_. Another option is to use _xorsearch_. It will try an look for strings that are encrypted with a simple XOR key.

| arg | description                                                                  |
| --- | ---------------------------------------------------------------------------- |
| -i  | Case-insensitive search                                                      |
| -s  | Generate a file that decodes all bytes in the file using the discovered key- |

This will go through the sample and try to xor substring and report if they have _"http:"_ part of it

```
xorsearch -i -s sample.bin http:
```

Another tool is _brxor_ it will deobfuscate XOR-encoded strings that in the English dictionary. Will go through the sample and save it to a file.

```
brxor.py sample.bin > sample_brxor.txt
```

There are many other similar tools to try:

* xorBruteForcer.py: http://eternal-todo.com/var/scripts/xorbruteforcer
* NoMoreXOR.py: https://github.com/hiddenillusion/NoMoreXOR
* xortool: https://github.com/hellman/xortool
* unXOR: https://github.com/tomchop/unxor
* Kahu tools: http://www.kahusecurity.com/tools



### Packed malware

Packers are tools that compress, obfuscate, encrypt or other methods to encode the original code. When the program runs it will decode the code into memory at run time. It is important that prior to starting the analysis assess whether the sample is packed, as it can alter the whole process. Analysis of packed executables is difficult because the code is encoded in such a way that makes it unreadable. Dynamic analysis of the packed program's code is still possible, but the process is more complex, as you first have to identify the unpacking function location. This does not mean that only malware is packed, there is a legit reason for using packers, such as protecting the algorithms used in trading software. The reason the malware authors choose to pack the code is to avoid AV detection giving more time before it is detected.

If you are able to identify the packer used it can help identify the path needed to unpack the sample, in some cases a tool that will automate the process for you. One of the best resources I found that automates the unpacking process is [unpac.me](https://www.unpac.me/#/), but as with any other public service when you upload a sample it will become publicly available to everyone.

Before we go more into depth on how to unpack malware. We first need a method for identifying if a sample is packed or not. Indicators of packed code:

* Few readable strings
* High entropy in the file (6.5)
* Very few imports
* Small code segments

To check the entropy of an executable tool such as _PeStudio, Detect It Easy, PEBear_. If you see an entropy score of 6.5 and above the chance of it being packed is very high.

\-WIP- Thrown in a picture of _Detect It easy_

_Diec_ is a command line tool that will try and detect it if the sample is packed and the packer used.

```
diec sample.exe
```

_diec output:_

```bash
PE32
    Protector: VMProtect(-)[Min protection]
    Compiler: Microsoft Visual C/C++(2003)[-]
    Linker: Microsoft Linker(7.10)[Console32,console]
```

Common packing techniques:

* Entry point modification of the sample so that it points to the beginning of the unpacking code instead.
* The import Address Table (IAT) part of the PE header is encoded making it harder to identify the external dependencies.

Here are the stages of the unpacking processes:

| Stage 1                | stage 2                                  | stage 3                     |
| ---------------------- | ---------------------------------------- | --------------------------- |
| Execute packed program | unpacks the code and stores it in memory | Original code gets executed |

#### Packing techniques

There are mainly two types of packing techniques. The first method of unpacking is either using a _native RWX memory code segment in PE_ or _allocating a new RWX code segment_. Let's take a look at the different stages of the allocation method:

1. Allocate memory
2. Fill the new segment with code
3. Fix the IAT
4. Jump to the code.

The second method of unpacking is to unpack into another process. This method uses the process hollowing technic.

1. create a new "suspended" process
2. Unmap then replace all the segments
3. Set origin EIP
4. Unsuspend the process

#### Unpacking

There exist multiple paths for unpacking code, and the method used depends on the packer that is used. The easiest is if the sample is packed with [UPX](https://upx.github.io/), which is a free packer. That comes with a built-in unpacking feature, by using the following command:

```bash
upx -d 
```

Are you faced with samples that are not being packed with _UPX_. The first step starting the unpacking process, is you need to disable the _ASLR_ on the sample, the method of doing so on Windows be viewed in Window section of this chapter. The easiest and fastest way is to run the malware, and wait for it to unpack itself into memory and then extract it from there.\
This can be done using [_Scylla_](https://github.com/NtQuery/Scylla). It works very much like an debugger, in that it will attach itself to an process.\
However This techniques does not work in all cases. And the extracted executable will not be runnable due to entry points and PE header issues.

_Process of dumping unpacked process and fixing the import table_

1. Dump - Save the process to disk
2. IAT autosearch - Look for import address table
3. Get Imports - acquire the imports
4. Fix Dump - fix the dump IAT.

When dumping files from memory using the techniques below it important to know how to fix the IAT and entry point of the file. This can be done using _Xdbg_ with a few plugins:

1. _Plugins â‡’ OllyDebugEx â‡’ Get EIP as OEP â‡’ Fix Virtual offset â‡’ Dump Fix imports_
2. _Plugins â‡’ scylla â‡’ IAT autosearch â‡’ Get imports â‡’ Fix Dump_

The sample is still not runnable as the entry point still points to the unpacking code. We have to change it to point to the begging of the code instead.\\

**Memory map unpacking technique**

This technique involves looking for the memory section with the executable flag _E_ in the protection column with readable strings in the region and extracting the data from memory. You can achieve this with _Xdbg_.

1. First load and run the sample in _Xdbg_
2. Go over to memory map and locate regions of the process memory that have executable flag (E) in protection column, the unpacked code is probably in one of those segments
3. Right click _follow in disassembler_
4. Search for strings in region, look for readable strings to identify if you have located the unpacked sample.
5. Extract the memory section and with the IAT and entrypoint with scylla.

_In some cases the region is encrypted, do the previous steps and:_

1. Search for intermodular calls in region, to _CryptDecrypt_, and other decryption API calls.
2. Set an hardware beakpoint at the encryption call, This is because the code changes at run time, and software breakpoint will not work as it will be overwritten by the code. (Debugger change the code to CC indicating where to stop.)
3. Rerun the sample.
4. It will now stop at the hardware breakpoint
5. Step over the decryption function
6. You can now extract the executable and fix it up.

**Window API unpacking**

The method relies on the packer to allocate new memory and write the program to it. The first step is to identify where the sample call _VirtualAlloc(Ex)_, If the VirtualAlloc is set with flProtect of 0x40 it is set with _PAGE\_EXECUTE\_READWRITE_. The process can now write data into a new memory location either in itself or external process.\
VirtualAlloc just allocates new memory, meaning it will empty at first. A good technique is to obverse memory section in _Xdbg_ is set a hardware breakpoint on the memory region, that gets triggered when the region is executed. You can identify if the new code is in an executable or dll by the file head _MZ_ (4D 5A).

Another approach is to use VirtualProtect. In xdbg you set a breakpoint on VirtualProtect. Run the code until you hit the breakpoint. In the stack view look at the first parameter, this is the memory region whose protection that will be changed.\
Right-click on the parameter and _follow in dump_\
You now need to identify if the presence of _MZ_ is present in the region. If it is then you have identified an executable.

You can now extract the memory region, by right click on the memory region and select _Follow in memory map_ In the memory map. the memory region, we are interested in should now be highlighted. Right-click and _dump memory to file_

You now need to fix the alignment of raw and virtual with [pe\_unmapper](https://github.com/hasherezade/libpeconv/tree/master/pe\_unmapper) using the base address of the memory region, to ensure it is in disk format.

```
pe_umapper /in sample.bin /base #baseaddress /out sample_fixed.bin
```

These techniques will not work on all packers, as Some packers are too complex for the method described above to work, even if you dump the process it might not be able to run due to entry point, IAT or other problems. In these cases, it could be best to allow the sample to run inside the debugger.



### Self-defending malware

As Malware authors gets better. They are started to introduce self-defending capabilities. Such as detecting virtualization, and looking for analysis tools such as a debugger, network monitor, etc.\
If the malware detects that it is being analysed it might terminate itself and in some cases, it will even delete itself from the system.\
making it harder for us to perform analysis specially with sandbox and dynamic analysis.

One way of dealing with this is to execute the sample while attached to a debugged and identify where in the code the sample tries to detect for analysis. e.g. _IsDebuggerpresent_\
And patching the instruction either by reversing the jump so that it only runs if there is a debugger present or filling it with _nop_ making the sample never take the jump. After patching the sample it removes the capability of detecting analysis. Malware samples rarely only have a single detection function. Some Samples have multiple, making this process very time-consuming.\
If you are using xdbg to debug your sample. [ScyllaHide](https://github.com/x64dbg/ScyllaHide) can be used It is an Anti-Anti-Debug, it works hiding the presence of a debugger. It comes with multiple options that can be used to hide the debugger from the malware. The more option you enable the more unstable the program can become.

Virtualization detection is another important factor for the malware author.\
Some of the common techniques are to check hardware characteristics, it is common for malware especially sandbox to only have a single core or the screen resolution to be very small, and then there is the up time of the system, as sandbox has a very low up time.\
Another is checking the application and services installed on the system. There are many ways for malware can detect if it in a virtual or physical environment

### Tip and trick

These are some of the techniques that have been developed as I programmed software and from reverse-engineered software, Some of these are Windows-specific.

* Tricky calls, Look out for tricky jumps via TLS, SEH, RET, CALL, etc. An example is using _PUSH_ to add an address to the stack and then use _RET_ to pop the address of the stack and jump to the given address.
* Utility functions, If there isn't an test after an call it most likely not of interest as the function called not does have an return value and most likely an utility function.
* Decryption function, If the same function is called multiple times there high possibility it a decryption function
* Syscalls, Instead of using ntdll.dll to make syscalls, they are instead directly called by using the syscall ID of the call we want to execute.
* Debugging self-changing code, When you set breakpoints in a debugger you are setting software breakpoints, the way this work is by changing a piece of code to _CC_ will indicate that the debugger needs to stop here. The problem with this method when working with a self-changing sample is that the breakpoint (_CC_) will be overwritten either by the packer, decryption function or similar functions. This is why it important to set hardware break (you can set a maximum of 4 hardware breakpoints)

